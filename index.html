<!doctype html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <title>Project R, jeu triple A</title>
    <script src="phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script src=»//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js »></script>
    <script type="text/javascript">
        var config = {
            type: Phaser.AUTO,
            width: 1280,
            height: 720,
            transparent: true,
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: {
                    debug: true
                }
            }
        };

        var game = new Phaser.Game(config);

        function preload() {
            this.load.image('sky', 'assets/sky.png');
            this.load.image('ground', 'assets/groundmvp.png');
            this.load.image('groundinvi', 'assets/groundinvi.png');

            this.load.spritesheet('perso', 'assets/perso-run.png', {
                frameWidth: 88,
                frameHeight: 94
            })

            this.load.spritesheet('perso-down', 'assets/perso-down.png', {
                //frameWidth: 118,
                //frameHeight: 94
                frameWidth: 88,
                frameHeight: 94
            })

            this.load.spritesheet('perso-up', 'assets/perso-jump.png', {
                frameWidth: 88,
                frameHeight: 94
            })

            this.load.spritesheet('enemy-1', 'assets/enemy1.png', {
                frameWidth: 70,
                frameHeight: 80
            })

            this.load.spritesheet('enemy-2', 'assets/enemy2.png', {
                frameWidth: 70,
                frameHeight: 80
            })

            this.load.spritesheet('enemy-3', 'assets/enemy3.png', {
                frameWidth: 70,
                frameHeight: 80
            })

            this.load.spritesheet('enemy-spe1', 'assets/enemy-spe1.png', {
                frameWidth: 70,
                frameHeight: 80
            })
        }

        function create() {
            this.gameSpeed = 6;

            this.respawnTime = 0;

            this.input.keyboard.on('keydown_ESC', function () {
                //  Every single animation in the Animation Manager will be paused:
                if (this.anims.paused) {
                    this.anims.resumeAll();
                    this.gameSpeed = 6;
                }
                else {
                    this.anims.pauseAll();
                    this.ground.tilePositionX = 0;
                    this.gameSpeed = 0;
                }
            }, this);

            const { height, width } = this.game.config;
            this.add.image(640, 360, 'sky');

            this.ground = this.add.tileSprite(0, height, width, 170, 'ground').setOrigin(0, 1);

            // var platforms;
            platforms = this.physics.add.staticGroup();
            platforms.create(400, 680, 'groundinvi').setScale(2).refreshBody();
            platforms.create(400, 245, 'groundinvi').setScale(2).refreshBody();

            // let player
            player = this.physics.add.sprite(100, 400, 'perso');
            player.setCollideWorldBounds(true);
            player.setGravityY(5000);
            this.physics.add.collider(player, platforms);

            // console.log(this.physics.add.collider(player, platforms))

            this.anims.create({
                key: 'running',
                frames: this.anims.generateFrameNumbers('perso', { start: 0, end: 15 }),
                frameRate: 16,
                repeat: -1
            });

            this.anims.create({
                key: 'down',
                frames: this.anims.generateFrameNumbers('perso-down', { start: 0, end: 15 }),
                frameRate: 16,
                repeat: -1
            });

            this.anims.create({
                key: 'jump',
                frames: this.anims.generateFrameNumbers('perso-up', { start: 0, end: 8 }),
                frameRate: 16,
                repeat: -1
            });

            this.anims.create({
                key: 'enemy1', // on choisi la spritesheet
                frames: this.anims.generateFrameNumbers('enemy-1', { start: 0, end: 1 }), // On défini la taille d'une frame dans preloadScene et ici on lui dit qu'il doit utiliser les frames de la position 0 à 1 pour l'animation
                frameRate: 10, // l'action va se répéter 6/sec
                repeat: -1 // afin de le répeter en boucle
            })

            this.anims.create({
                key: 'enemy2', // on choisi la spritesheet
                frames: this.anims.generateFrameNumbers('enemy-2', { start: 0, end: 1 }), // On défini la taille d'une frame dans preloadScene et ici on lui dit qu'il doit utiliser les frames de la position 0 à 1 pour l'animation
                frameRate: 10, // l'action va se répéter 6/sec
                repeat: -1 // afin de le répeter en boucle
            })

            this.anims.create({
                key: 'enemy3', // on choisi la spritesheet
                frames: this.anims.generateFrameNumbers('enemy-3', { start: 0, end: 1 }), // On défini la taille d'une frame dans preloadScene et ici on lui dit qu'il doit utiliser les frames de la position 0 à 1 pour l'animation
                frameRate: 10, // l'action va se répéter 6/sec
                repeat: -1 // afin de le répeter en boucle
            })

            this.anims.create({
                key: 'enemy--spe1', // on choisi la spritesheet
                frames: this.anims.generateFrameNumbers('enemy-spe1', { start: 0, end: 1 }), // On défini la taille d'une frame dans preloadScene et ici on lui dit qu'il doit utiliser les frames de la position 0 à 1 pour l'animation
                frameRate: 10, // l'action va se répéter 6/sec
                repeat: -1 // afin de le répeter en boucle
            })

            this.obsticles = this.physics.add.group();


            console.log(player.body.deltaAbsY());
            console.log(player.body.y);
            console.log(player);

            var jumpTime = 0;
            var downTime = 0;

            this.input.keyboard.on('keydown_SPACE', () => {
                if (!jumpTime == 0) { return; }
                player.body.height = 92;
                player.body.offset.y = 0;
                player.setVelocityY(-1600);
                player.anims.play('jump', true);
                jumpTime = 1;
            })


            this.input.keyboard.on('keyup_SPACE', () => {
                jumpTime = 0;
            })


            this.input.keyboard.on('keydown_DOWN', () => {
                if (!downTime == 0) { return; }
                player.body.height = 58;
                player.body.offset.y = 34;
                downTime = 1;
                setTimeout(reUp, 150);
            })

            this.input.keyboard.on('keyup_DOWN', () => {
                downTime = 0;
            })

            if (this.physics.add.collider(player, platforms).active == true) {
                player.anims.play('running', true);
            }

            if (player.body.deltaAbsY() > 0) {
                player.anims.play('jump', true);
            } else {
                player.body.height <= 58 ?
                    player.anims.play('down', true) :
                    player.anims.play('running', true);
            }
        }

        /*function placeObsticles() {
            const { width, height } = this.game.config;

            const obsticleNum = Math.floor(Math.random() * 4) + 1; // on décide de l'obstacle à générer
            const distance = Phaser.Math.Between(100, 300); // on défini la distance à laquelle l'obstacle est généré
            let obsticle;

            if (obsticleNum > 3) { // si le num de l'obstacle est supérieur à 6
                const enemyHeight = [22, 60]; // on défini son apparition soit à 22px du sol soit à 50 soit deux possibilités de spawn
                obsticle = this.obsticles.create(width + distance, height - enemyHeight[Math.floor(Math.random() * 2)], 'enemy-spe1'); // on tire un nombre au hasard entre 1 et 2 pour savoir si on place l'obstacle à 22 ou 50 px et on défini l'asset de l'obstacle (l'oiseau ici)
                obsticle.play('enemy--spe1', 1); // on anime l'oiseau
                obsticle.body.height = obsticle.body.height / 1.5;
            } else {
                obsticle = this.obsticles.create(width + distance, height, `enemy${obsticleNum}`);
                obsticle.play(`enemy${obsticleNum}`, 1);
                obsticle.body.offset.y = +10;
            }

            obsticle
                .setOrigin(0, 1)
                .setImmovable();
        }*/

        function reUp() {
            player.body.height = 92;
            player.body.offset.y = 0;
        }

        function update(time, delta) {
            const { width, height } = this.game.config;
            this.ground.tilePositionX += this.gameSpeed;

            if (player.body.deltaAbsY() > 0) {
                player.anims.play('jump', true);
            } else {
                player.body.height <= 58 ?
                    player.anims.play('down', true) :
                    player.anims.play('running', true);
            }


            Phaser.Actions.IncX(this.obsticles.getChildren(), - this.gameSpeed);

            this.respawnTime += delta * this.gameSpeed * 0.08; // on défini le temps de respawn

            if (this.respawnTime >= 500) {
                var obsticleNum = Math.floor(Math.random() * 4) + 1;
                var distance = Phaser.Math.Between(600, 900);
                var obsticle;
                var enemyHeight = [100, 300];

                if (obsticleNum > 3) {
                    obsticle = this.obsticles.create(width + distance, height - enemyHeight[Math.floor(Math.random() * 2)], 'enemy-spe1');
                    obsticle.play('enemy--spe1', 1);
                    obsticle.body.height = obsticle.body.height / 1.5;
                } else {
                    obsticle = this.obsticles.create(width + distance, height - enemyHeight[Math.floor(Math.random() * 2)], `enemy${obsticleNum}`)
                    obsticle.play(`enemy${obsticleNum}`, 1);
                    obsticle.body.offset.y = +10;
                }

                obsticle.setOrigin(0, 1).setImmovable();
                this.respawnTime = 0;
            }

            this.obsticles.getChildren().forEach(obsticle => { // pour chaque obstacle qui passe à gauche on les supprime
                if (obsticle.getBounds().right < 0) {
                    obsticle.destroy();
                }
            })


        }
    </script>
</body>

</html>